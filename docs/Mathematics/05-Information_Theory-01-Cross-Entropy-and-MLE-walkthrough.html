<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="ipynb_website:version" content="0.9.6" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="stylesheet" type="text/css" href="../css/jt.css">
<link rel="stylesheet" type="text/css" href="../css/readable.css">
<link rel="stylesheet" type="text/css" href="../css/toc2.css">

<link href="../site_libs/jqueryui-1.11.4/jquery-ui.css">
<link rel="stylesheet" href="../site_libs/bootstrap-3.3.5/css/readable.min.css" rel="stylesheet" />
<link rel="stylesheet" href="../site_libs/font-awesome-4.5.0/css/font-awesome.min.css" rel="stylesheet" />
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.9.1/jquery-ui.min.js"></script>
<script src="../site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="../site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="../site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>

<link rel="stylesheet"
      href="../site_libs/highlightjs/null.min.css"
      type="text/css" />

<script src="../site_libs/highlightjs/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>

<script src="../js/doc_toc.js"></script>
<script src="../js/docs.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
        },
        "HTML-CSS": {
            preferredFont: "TeX",
            availableFonts: ["TeX"],
            styles: {
                scale: 110,
                ".MathJax_Display": {
                    "font-size": "110%",
                }
            }
        }
    });
</script>
<script>
function filterDataFrame(id) {
    var input = document.getElementById("search_" + id);
    var filter = input.value.toUpperCase();
    var table = document.getElementById("dataframe_" + id);
    var tr = table.getElementsByTagName("tr");
    // Loop through all table rows, and hide those who don't match the search query
    for (var i = 1; i < tr.length; i++) {
        for (var j = 0; j < tr[i].cells.length; ++j) {
            var matched = false;
            if (tr[i].cells[j].innerHTML.toUpperCase().indexOf(filter) != -1) {
                tr[i].style.display = "";
                matched = true
                break;
            }
            if (!matched)
                tr[i].style.display = "none";
        }
    }
}
function sortDataFrame(id, n, dtype) {
    var table = document.getElementById("dataframe_" + id);
    var tb = table.tBodies[0]; // use `<tbody>` to ignore `<thead>` and `<tfoot>` rows
    var tr = Array.prototype.slice.call(tb.rows, 0); // put rows into array
    if (dtype === 'numeric') {
        var fn = function(a, b) { 
            return parseFloat(a.cells[n].textContent) <= parseFloat(b.cells[n].textContent) ? -1 : 1;
        }
    } else {
        var fn = function(a, b) {
            var c = a.cells[n].textContent.trim().localeCompare(b.cells[n].textContent.trim()); 
            return c > 0 ? 1 : (c < 0 ? -1 : 0) }
    }
    var isSorted = function(array, fn) {
        if (array.length < 2)
            return 1;
        var direction = fn(array[0], array[1]); 
        for (var i = 1; i < array.length - 1; ++i) {
            var d = fn(array[i], array[i+1]);
            if (d == 0)
                continue;
            else if (direction == 0)
                direction = d;
            else if (direction != d)
                return 0;
            }
        return direction;
    }
    var sorted = isSorted(tr, fn);
    if (sorted == 1 || sorted == -1) {
        // if sorted already, reverse it
        for(var i = tr.length - 1; i >= 0; --i)
            tb.appendChild(tr[i]); // append each row in order
    } else {
        tr = tr.sort(fn);
        for(var i = 0; i < tr.length; ++i)
            tb.appendChild(tr[i]); // append each row in order
    }
}
</script>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');
  // mark it active
  menuAnchor.parent().addClass('active');
  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>
<div class="container-fluid main-container">
<!-- tabsets -->
<script src="../site_libs/navigation-1.1/tabsets.js"></script>
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>



<title>Nathaniel Dake Blog</title>

<style type = "text/css">
body {
  font-family: "Spectral-Light";
  padding-top: 66px;
  padding-bottom: 40px;
}
</style>
</head>

<body>
<div tabindex="-1" id="notebook" class="border-box-sizing">
<div class="container" id="notebook-container">

<!-- code folding -->

<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">Nathaniel Dake Blog</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        
<li>
  <a href="../Deep_Learning.html">Deep Learning</a>
</li>
        
<li>
  <a href="../Machine_Learning.html">Machine Learning</a>
</li>
        
<li>
  <a href="../Mathematics.html">Mathematics</a>
</li>
        
<li>
  <a href="../AI.html">AI</a>
</li>
        
<li>
  <a href="../NLP.html">NLP</a>
</li>
        
      </ul>
        
<ul class="nav navbar-nav navbar-right">
<li>
   <a href="https://github.com/NathanielDake/nathanieldake.github.io"> source </a>
</li>
</ul>
        
      </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="1.-Cross-Entropy-and-Maximum-Likelihood-Estimation">1. Cross Entropy and Maximum Likelihood Estimation<a class="anchor-link" href="#1.-Cross-Entropy-and-Maximum-Likelihood-Estimation">&#182;</a></h1><p>If you have gone through any of my other walkthroughs on machine learning, particularly those on <strong>Logistic Regression</strong>, <strong>Neural Networks</strong>, <strong>Decision Trees</strong>, or <strong>Bayesian machine learning</strong> you have definitely come across the concept of <strong>Cross Entropy</strong> and <strong>Maximum Likelihood Estimation</strong>. Now, when discussed separately, these are relatively simple concepts to understand. However, during the creation of these notebooks, particularly the sections on logisitic regression and neural networks (and the cost functions involved), I felt as though it was not clear why they were related in certain cases.</p>
<p>This notebook is meant to do three things:</p>
<ol>
<li>Describe <strong>Cross Entropy</strong> in detail</li>
<li>Describe <strong>Maximum Likelihood Estimation</strong> in detail</li>
<li>Describe how the <strong>Cross Entropy</strong> can be equivalent to the negative <strong>log-likelihood</strong>, such as in the cost function in a neural network.</li>
</ol>
<p>So, with that said, lets get started talking about Cross Entropy.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="1.1.-Cross-Entropy">1.1. Cross Entropy<a class="anchor-link" href="#1.1.-Cross-Entropy">&#182;</a></h1><p>When we develop a model for probabilistic classification, we are trying to figure out how to map the models <strong>inputs</strong> to <strong>probabilistic predictions</strong>, with the goal that these are very close to the <strong>ground-truth probabilities</strong>. The <strong>training</strong> process is done by iteratively adjusting the model's parameters so that our predictions get closer and closer to the ground-truth.</p>
<p>Say we are trying to build a model that can determine whether an image contains a dog, a cat, or a fish. If, for instance, we input an image that contains a fish, we are hoping that the output is:</p>
$$y = \begin{bmatrix}
    0 \\
    0 \\
    1
\end{bmatrix}$$<p>Since that vector represents the <strong>ground-truth class probabilities</strong>- in this case 0 for dog, 0 for cat, and 1 for fish. If our model ended up predicting a different probability distribution, for instance:</p>
$$\hat{y}= \begin{bmatrix}
    0.3 \\
    0.2 \\
    0.5
\end{bmatrix}$$<p>Then we would want to adjust our parameters so that $\hat{y}$ gets closer to $y$. The question is: What exactly do we mean when we say "get's closer to"? How should we measure the difference between $\hat{y}$ and $y$? One possible measure is <strong>cross entropy</strong>.</p>
<h2 id="1.2-Entropy">1.2 Entropy<a class="anchor-link" href="#1.2-Entropy">&#182;</a></h2><p>In the context of <strong>information theory</strong>, what is <strong>entropy</strong>? Let's look at an example first. Say you are standing along a road, and you want to communicate each car model that you see pass to a friend. The only means that you have to communicate with your friend is a binary channel where you can only send 0 or 1, and each particular bit costs 10 cents. To do this, you will need bit sequences, one to represent each car model.</p>
<p>Lets assume you are trying to minimize the amount of money you have to spend. How would you decide to assign bit sequences to car models? Would you use the same number of bits for a Toyota Camry as you would for a corvette? No, you wouldn't! Clearly you know that the camry is far more common, and you will be communicating to your friend that you saw a camry far more often, so you want to assign it a smaller sequence of bits. In other words, you are exploiting your knowledge about the distribution over car models to reduce the number of bits that you need to send on average.</p>
<p>Well, it turns out that if you have access to the underlying distribution of cars on the road, $y$, then if you want to use the smallest number of bits on average, you should assign $log(\frac{1}{y_i})$ bits to the $i$th symbol. (Remember, $y_i$ is the probability of the $i$th symbol).</p>
<p>For example, if we assume that seeing a Camry is 128 times as likely as seeing a corvette, then we'd give the Camry 7 less bits than the Tesla symbol:</p>
$$b_{camry} = log\frac{1}{128p_{corvette}} = log\frac{1}{p_{corvette}} + log\frac{1}{128} = b_{corvette}-7$$<p>If we fully exploit the known distribution of cars, $y$, in this way, we can achieve an optimal number of bits per transmission. The optimal number of bits is known as <strong>entropy</strong>. Mathematically, it's just the expected number of bits under this optimal encoding.</p>
$$H(y) = \sum_iy_ilog\frac{1}{y_i} = -\sum_iy_ilog(y_i)$$<p>Where again, $y_i$ is the probability of seeing the $i$-th symbol, i.e. a corvette, and $log\frac{1}{y_i}$ is the number of bits we have assigned to it. So this equation just means that we take the probability of seeing each car, and multiply that by the number of bits we have assigned to it, and that is the total number of bits we would be expecting to transmit.</p>
<h2 id="1.3-Information">1.3 Information<a class="anchor-link" href="#1.3-Information">&#182;</a></h2><p>Now, you may very well be wondering: why are we taking the logarithm of the above inverse probability $\frac{1}{y_i}$? I mentioned that it "turns out" that with the underlying distribution, then this is the number of bits you should assign to the $i$th symbol; but why?</p>
<p>In order to fully grasp that, the concept of <strong>information</strong> must be introduced. A full post will be dedicated to it in the future, but for now we will focus in on a specific type of information known as <strong>Shannon Information</strong> (named after the founder of information theory, Claude Shannon), and define it as follows:</p>
<blockquote><p><strong>Shannon Information</strong> is a measure of <em>surprise</em>.</p>
</blockquote>
<p>Now what exactly do I mean when referencing "surprise"? Well, take our car example again. When a camry passes us we experience little surprise, since it is very common. On the other hand, when the rare Tesla passes by we experience a good deal of surprise; we were not expecting it! Well, as Claude Shannon was considering how to define information he realized that this concept of "surprise" was absolutely crucial.</p>
<p>A simple was to mathematically define surprise would be:</p>
$$information = surprise = \frac{1}{\text{probability of event}}$$<p>In the above definition, if the probability of our event was 0.01 (a rare event), then our $surpise$ would be $100$. However, for a very common event with a probability of 0.9, our $surprise$ would be $1.11$.</p>
<p>This definition on first glance seems to quantify surprise very well! However, as Shannon was trying to create his official definition of information, he realized that in order for it be useful it would have to be <em>additive</em>. This simply means that the information associated with a set of outcomes should be equal to the sum of the information associated with each individual outcome. Shannon showed that in order to satisfy this <em>additive</em> condition, we are better off defining information as as:</p>
$$information = surprise = log(\frac{1}{\text{probability of event}})$$<p>The definition above is that of <strong>Shannon Information</strong>. Now, how Shannon proved that will be saved for another post, but the important thing to remember is that it was <em>chosen for a reason</em>, not simply plucked out of thin air.</p>
<p>One final thing to keep in mind is that another way of viewing <em>Entropy</em>, is as the <em>average shannon information</em>. In other words, it is the <em>expected value of the shannon information</em>. Recall, the definition of expected value is:</p>
$$E \big[ X \big] = \sum_{i}^k x_ip_i = x_1p_1 + x_2p_2 + ... + x_kp_k$$<p>Which, we can apply to shannon information:</p>
$$Entropy = E \big[\text{Shannon Information} \big] = \sum_{i}^k \text{Probability of event $i$}*log\Big(\frac{1}{\text{probability of event $i$}}\Big)$$<p>And this is exactly what we found in section 1.2! A succicint definition of Entropy may sometimes take the form:</p>
$$Entropy = H(X) = E \Big[ log(\frac{1}{p(x)})\Big]$$<h2 id="1.4-Cross-Entropy">1.4 Cross Entropy<a class="anchor-link" href="#1.4-Cross-Entropy">&#182;</a></h2><p>Now, if we think of a distribution as the tool we use to encode symbols, then entropy measures the number of bits we'll need if we use the <em>correct</em> tool, $y$, the <strong>ground-truth probability distribution</strong>. This is optimal, in that we can't encode the symbols using fewer bits on average.</p>
<p><strong>However</strong>, <strong>cross entropy</strong> represents the number of bits we will need if we encode symbols from $y$ using the <em>wrong</em> tool $\hat{y}$. In other words, if the probabilty distribution that our model learns, $\hat{y}$, is not the same as $y$ (which it almost never will be), then <strong>cross entropy</strong> represents the number of bits used in the encoding. We would have encoded the $i$th symbol with $log\frac{1}{\hat{y_i}}$ bits, instead of $log\frac{1}{y_i}$ bits.</p>
<p>We of course will still be utilizing the value of the true distribution $y$, since that is the distribution we will actually encounter (if this is unclear, all it means is that you create the encoding scheme <em>before</em> you actually see the number of cars, meaning you use a distribution you are hoping is close the the correct one. We call this distribution $\hat{y}$. However, when actually determining how many bits you use, that is based on <em>actual</em> cars that pass you, which is the true distribution, $y$.). Mathematically this looks like:</p>
$$H(y, \hat{y}) = \sum_iy_ilog\frac{1}{\hat{y_i}} = -\sum_iy_ilog\frac{1}{\hat{y_i}}$$<p><strong>Cross entropy</strong> is <em>always</em> larger than <strong>entropy</strong>. Encoding symbols according to the wrong distribution $\hat{y}$ will always make us use more bits. The only exception is in the trivial case where $y$ and $\hat{y}$ are equal, and in this case entropy and cross entropy are equal.</p>
<h3 id="1.4.1-Cross-Entropy-Applied">1.4.1 Cross Entropy Applied<a class="anchor-link" href="#1.4.1-Cross-Entropy-Applied">&#182;</a></h3><p>In order to make the notion of cross entropy more concrete, I want to go through how it applies in a scenario such as logistic regression, and <em>why</em> it is the perfect choice for a cost function. We are going to start with the above definition of cross entropy:</p>
$$H(y, \hat{y}) = \sum_iy_ilog\frac{1}{\hat{y}_i}$$<p>Remember, the entire reason we that we have been delving into entropy is that we wanted to find a way to determine how "different" our <em>predicted distribution</em> is from the <em>target distribution</em>. For clarity, I am going to let our target distribution be represented as $t$, and the predicted distribution will remain $\hat{y}$.</p>
$$H(t, \hat{y}) = \sum_i t_i log\frac{1}{\hat{y}_i}$$<p>In the case of machine learning (think logistic regression), we have a set of <em>labels</em> which corresponds to our <em>target distribution</em>, $t$. Again, it will often have the form:</p>
$$t = \begin{bmatrix}
    0 \\
    0 \\
    1
\end{bmatrix}$$<p>The entire idea is that we want to <em>learn</em> this distribution, which is represented by $\hat{y}$. It may look like:</p>
$$\hat{y}= \begin{bmatrix}
    0.3 \\
    0.2 \\
    0.5
\end{bmatrix}$$<p>For one specific training example, we want to learn the distribution, and hope that it is very close the target distribution. We can determine <em>how far away</em> from the target distribution it is via the <em>cross entropy</em>. Now, let's say we are in a binary classification scenario, with classes $a$ and $b$. Our cross entropy would look like:</p>
$$H(t, \hat{y}) = t_a log(\frac{1}{\hat{y}_a}) + t_b log(\frac{1}{\hat{y}_b})$$<p>And recall, that in binary classification:</p>
$$t_b = 1 - t_a$$$$\hat{y}_b = 1 - \hat{y}_a$$<p>Hence, if we substitute those values in:</p>
$$H(t, \hat{y}) = t_a log \big(\frac{1}{\hat{y}_a}\big) + \big(1 - t_a\big) log \big(\frac{1}{1 - \hat{y}_a} \big)$$<p>And we can utilize the properties of logarithms to reduce our equation to:</p>
$$H(t, \hat{y}) = -\Big[ t_a log \big(\hat{y}_a\big) + \big(1 - t_a\big) log \big(1 - \hat{y}_a \big) \Big]$$<p>And, if we let $t_a$ just be represented as $t$, and $\hat{y}_a$ represented as $\hat{y}$:</p>
$$H(t, \hat{y}) = -\Big[ t log \big(\hat{y}\big) + \big(1 - t\big) log \big(1 - \hat{y} \big) \Big]$$<p>And that is the exact definition of the cross entropy cost function that we have encountered numerous times, specifically with logistic regression. Now, keep in mind that the above Cross entropy will only yield an output for <em>one training example</em>. We generally will have <em>many training examples</em>, and want to learn distributions for <em>all of them</em>. In that case, if we have $n$ training examples, we can determine the <em>total cross entropy</em> via:</p>
$$\text{Total Cross Entropy $\forall$ examples} = - \sum_n^N \Big[ t_n log \big(\hat{y}_n\big) + \big(1 - t_n\big) log \big(1 - \hat{y}_n \big) \Big]$$<p>We can quickly see why this is such a good cost function, specifically in the case of binary classification, with the following examples:</p>
$$\text{Cross Entropy}(t=1, y=1) \rightarrow = 0$$$$\text{Cross Entropy}(t=0, y=0) \rightarrow = 0$$$$\text{Cross Entropy}(t=1, y=0.9) \rightarrow = 0.11$$$$\text{Cross Entropy}(t=1, y=0.5) \rightarrow = 0.69$$$$\text{Cross Entropy}(t=1, y=0.1) \rightarrow = 2.3$$<p>We can see that the cross entropy is zero when there is no error, and that the more incorrect our prediction is, the larger the cross entropy becomes.</p>
<h2 id="1.5-KL-Divergence">1.5 KL Divergence<a class="anchor-link" href="#1.5-KL-Divergence">&#182;</a></h2><p>The <strong>KL Divergence</strong> from $\hat{y}$ to $y$ is simply the <strong>difference</strong> between <strong>cross entropy</strong> and <strong>entropy</strong>:</p>
$$KL(y \;||\; \hat{y}) = \sum_iy_ilog\frac{1}{\hat{y_i}} - \sum_iy_ilog\frac{1}{y_i} = \sum_iy_ilog\frac{y_i}{\hat{y_i}}$$<p>It measures the extra bits we'll need on average if we encode symbols from $y$ according to $\hat{y}$. It is never negative, and it is only 0 if $y$ and $\hat{y}$ are the same. Note that minimizing the <strong>cross entropy</strong> and minimizing the <strong>KL divergence</strong> from $y$ to $\hat{y}$ are the same thing.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="2.-Maximum-Likelihood">2. Maximum Likelihood<a class="anchor-link" href="#2.-Maximum-Likelihood">&#182;</a></h1><h2 id="2.1-Introduction">2.1 Introduction<a class="anchor-link" href="#2.1-Introduction">&#182;</a></h2><p>One thing that we try and do during machine learning is maximize the likelihood of our data, given our particular model. This really means that we are trying to say: "How likely is it that we received these outputs, given our model is true". As an example, say we have trained a model to predict whether an image is of a cat or a dog. Now lets say we run predictions on 3 images of dogs, but our model predicts they are all cats. In that case our data was 3 images of dogs, and our model got all predictions wrong. So we could say that, if our model was in fact correct, the likelihood of our input data really being 3 dogs is very low. Our goal is to find a model that <strong>maximizes the likelihood of our data</strong>. So we would want a model that predicts all 3 images are dogs.</p>
<p><br></br></p>
<h2 id="2.2-Coin-Toss-Example">2.2 Coin Toss Example<a class="anchor-link" href="#2.2-Coin-Toss-Example">&#182;</a></h2><p>Let's look at an example where try and calculate the likelihood for a biased coin. Say we have a coin with a probability of heads, $p(H)$, equal to $p$:
$$p(H) = p$$
In this case, $p$ is a parameter. The probability of tails (since this is a bernoulli trial), is:
$$p(T) = 1 - p$$
Now we are going to run an experiment to help us determine $p$. We flip a coin 10 times and we get 7 heads and 3 tails. We want to know how we would write the total likelihood, which is the probability of receiving the data (result) that we saw. The general form equation for the likelihood in a binomial experiment is:</p>
$$L(X\;|\;p) = p^k(1-p)^{N-k}$$<p>In this case $k$ is the total number of success's and $N$ is the total number of trials. In our example, we had 7 heads, so 7 success's, and 3 tails, so 3 failures, with 10 trials total. Our likelihood function then looks like:</p>
$$L(X\;|\;p) = p^7(1-p)^3$$<p>Note that we are able to do this because each coin toss is independent. Therefore we can multiply each probability! In other words the above equation came from multiplying each probability of each result together:</p>
$$p*p*p*p*p*p*p*(1-p)*(1-p)*(1-p)$$<p>Also, the likelihood can look just like a conditional probability. This is because the likelihood is used when our data, in this case $X$, has already been observed.</p>
<p>Now, we want to <strong>maximize the likelihood</strong>. In other words, we want to maximize $L$ with respect to $p$, our parameter. This means we want to choose a $p$ that maximizes $L$. This can be done using basic calculus. Note that in most of these problems we take the log and maximize the likelihood. This is acceptable because the log function is monotonically increasing.</p>
<p>Before we perform the maximizing of our likelihood, lets get a quick idea of what our Likelihood function actually looks like:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[1]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="o">%</span><span class="k">matplotlib</span> inline
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>




<div class="output_png output_subarea ">
<img src="data:image/png;base64,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
"
>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Okay great, we can see that from a visual perspective we should be expecting a value of ~0.7 to be the value of $p$ that maximizes the likelihood of observing our data!</p>
<p>Lets now go through the derivation. First we will take the log of the likelihood:
$$log(L) = l = log\Big(p^7*(1-p)^3\Big)$$
Then use the multiplication rule:
$$log(p^7) + log\Big((1-p)^3\Big)$$
Then the power rule:
$$7log(p) + 3log(1-p)$$
Set the derivative equal to zero:
$$\frac{dl}{dp} = \frac{7}{p}+\Big(-1*\frac{3}{1-p}\Big)= 0$$
And solve for p:
$$\frac{7}{p} = \frac{3}{1-p}$$
$$\frac{1-p}{p} = \frac{3}{7}$$
$$\frac{1}{p} -1 = \frac{3}{7}$$
$$\frac{1}{p} = \frac{10}{7}$$
$$p = \frac{7}{10}$$
This is what we would expect (visually it agrees)! If this is still slightly abstract, here is a visualization of exactly what is going on:</p>
<p><img src="https://drive.google.com/uc?id=1F6Vm2ucJCfZVy2Iy4sKz6NujXSV-b6FW"></p>
<p>We already have observed our data $X$, and we slowly change our parameter (in the visual above the parameter is now $\mu$, but it can be thought of as $p$. As we change the parameter, we can see that our probability distribution moves to the right. Once we find the parameter that maximizes the likelihood, we can see that the distribution on the left also is in the best place it can be.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><br></br></p>
<h2 id="2.-Predictive-Power">2. Predictive Power<a class="anchor-link" href="#2.-Predictive-Power">&#182;</a></h2><p>At this point, you may be happy to just use the cross entropy to measure the difference between two distributions, $y$ and $\hat{y}$, and then using the total cross entropy over all training examples as our loss function. In particular, if we let $n$ index our training examples, the overal loss would be:</p>
$$H(\{y^{(n)}\}, \{\hat{y}^{(n)}\}) = \sum_nH(y^{(n)}, \hat{y}^{(n)})$$<p>But let's look at another approach. What if we want our objective function to be a direct measure of our model's predictive power (at least with respect to our training data)? One common approach is to tune our parameters so that the <strong>likelihood</strong> of our data under the model is <strong>maximized</strong>. When performing <strong>classification</strong> we are often using a <em>discriminative model</em>, our "data" often just consists of the labels we are trying to predict. We can reason that a model that often predicts the ground-truth labels given the inputs might be useful, while a model that fails to predict the ground-truth labels is not useful.</p>
<p>Because we generally assume that our samples are <strong>independent and identically distributed</strong>, the likelihood over all of our examples decomposes into a product over the likelihoods of individual examples:</p>
$$L(\{y^{(n)}\}, \{\hat{y}^{(n)}\}) = \prod_nL(y^{(n)}, \hat{y}^{(n)})$$<p>And what is the likelihood of the $n$th example? It is just the particular entropy of $\hat{y}^{(n)}$ that corresponds to the ground truth label specified by $y^{(n)}$!</p>
<p>If we go back to our original example, if the first training image is of a fish, then:</p>
$$y^{(1)} = \begin{bmatrix}
    0 \\
    0 \\
    1
\end{bmatrix}$$<p>This tells us that the likelihood $L(y^{(1)}, \hat{y}^{(1)})$ is just the last entry of:</p>
$$\hat{y}= \begin{bmatrix}
    0.3 \\
    0.2 \\
    0.5
\end{bmatrix}$$<p>Which is $\hat{y}^{(1)} = 0.5$. Now lets that we have 4 training images labeled: <em>fish, cat, dog, cat</em>. This gives us our ground truth distribution: 
$$y^{(1)} = \begin{bmatrix}
    0 \\
    0 \\
    1
\end{bmatrix}$$
$$y^{(2)} = \begin{bmatrix}
    0 \\
    1 \\
    0
\end{bmatrix}$$
$$y^{(3)} = \begin{bmatrix}
    1 \\
    0 \\
    0
\end{bmatrix}$$
$$y^{(4)} = \begin{bmatrix}
    0 \\
    1 \\
    0
\end{bmatrix}$$</p>
<p>Our model would predict 4 other distributions:</p>
$$\hat{y}^{(1)},\hat{y}^{(2)},\hat{y}^{(3)},\hat{y}^{(4)}$$<p>And our overall likelihood would just be:</p>
$$L(\{ y^{(1)},y^{(2)},y^{(3)},y^{(4)}\}, \{\hat{y}^{(1)},\hat{y}^{(2)},\hat{y}^{(3)},\hat{y}^{(4)} \}) = \hat{y}^{(1)}\hat{y}^{(2)}\hat{y}^{(3)}\hat{y}^{(4)}$$<p>Maybe we would have been previously happy with just minimizing the cross entropy during training, but after seeing this, are we still happy? Why shouldn't we instead maximize the likelihood of our data?</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="3.-Unified-Loss-Function">3. Unified Loss Function<a class="anchor-link" href="#3.-Unified-Loss-Function">&#182;</a></h1><p>Let's take a minute to play with the expression above. Because a logarithm is monotonic, we know that maximizing the likelihood is equivalent to maximizing the <strong>log likelihood</strong>, which is in turn equivalent to <em>minimizing</em> the <strong>negative log likelihood</strong>.</p>
$$-log\Big(L(\{y^{(n)}\}, \{\hat{y}^{(n)}\})\Big)= - \sum_nlog\Big(L(y^{(n)}, \hat{y}^{(n)})\Big)$$<p>But, from the work we did earlier, we also know that the log likelihood of $y^{(n)}$ is just the log of a particular entry of $\hat{y}^{(n)}$. In fact, its the entry $i$ that satisfies $y_i^{(n)} = 1$. We can therefore rewrite the log likelihood for the nth training example in the following way:</p>
$$ \log L(y^{(n)}, \hat{y}^{(n)}) = \sum_i y^{(n)}_i \log \hat{y}^{(n)}_i $$<p>Which in turn gives us an overall negative log likelihood of:</p>
$$ - \log L(\{y^{(n)}\}, \{\hat{y}^{(n)}\}) = -\sum_n \sum_i y^{(n)}_i \log \hat{y}^{(n)}_i $$<p>Does this look familiar? This is exactly the <strong>cross entropy</strong>, summed over all training examples:</p>
$$ -\log L(\{y^{(n)}\}, \{\hat{y}^{(n)}\}) = \sum_n \big[-\sum_i y_i \log \hat{y}^{(n)}_i\big] = \sum_n H(y^{(n)}, \hat{y}^{(n)})$$
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="4.-Conclusions">4. Conclusions<a class="anchor-link" href="#4.-Conclusions">&#182;</a></h1><p>When we develop a probabilistic model over mutually exclusive classes, we need a way to measure the difference between predicted probabilities $\hat{y}$ and ground-truth probabilities $y$, and during training we try to tune parameters so that this difference is minimized.In this post we saw that cross entropy is a reasonable choice.</p>
<p>From one perspective, minimizing cross entropy lets us find a $\hat{y}$ that requires as few extra bits as possible when we try to encode symbols from $y$ using $\hat{y}$.</p>
<p>From another perspective, minimizing cross entropy is equivalent to minimizing the negative log likelihood of our data, which is a direct measure of the predictive power of our model.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[&nbsp;]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> 
</pre></div>

    </div>
</div>
</div>

</div>
<hr>
&copy; 2018 Nathaniel Dake

</div>
</div>
</body>
</html>
